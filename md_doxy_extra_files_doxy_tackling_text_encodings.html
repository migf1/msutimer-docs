<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MSUTimer: Tackling Text Encodings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MSUTimer
   &#160;<span id="projectnumber">v0.01 alpha</span>
   </div>
   <div id="projectbrief">Simple High Resolution Timer for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doxy_extra_files_doxy_tackling_text_encodings.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tackling Text Encodings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Things are straight forward when strings comply with single-byte text encodings, like the default ASCII charset used in all previous code snippets. However, it's not the same with multi-byte text encoded strings. UTF-8 is the most popular such example.</p>
<p>In these cases, the <b>length</b> of a string <b>no longer</b> reflects the count of "characters", but rather the count of bytes (excluding null-termination). That's because any text-encoded "character" may consist of more than 1 bytes. Moreover, some text-encodings may use zero-bytes to encode their multi-byte "characters" (for example, 'A' in UTF-16 is 0x0041 or 0x4100, depending on the endianness). Furthermore, the null "character" (<code>NUL</code> for brevity) may use more than 1 bytes, which in some encodings may not even be zero (for example, UTF-16 <code>NUL</code> is 0x000, but Java's modified UTF-8 <code>NUL</code> is 0xC080).</p>
<blockquote class="doxtable">
<p><em>MyStr</em> does <b>not</b> handle text-encodings per se. It does provide a few bonus UTF-8/UTF-16/UTF-32 conversion utility-functions relying on <em>libiconv</em>, along with a few more stand-alone UTF convenience utility-functions, but none of them is <em>mstrings</em> specific. Meaning that <em>MyStr</em> core functions performing indexing, insertion, deletion, subranging, searching, etc, on <em>mstrings</em> are fine with single-byte text-encodings, but they are rarely (if ever) suitable for multi-byte encoded strings. </p>
</blockquote>
<p><b>However</b>, <em>MyStr</em> can still prove helpful when it comes to things like concatenation, copying, byte comparisons, etc, for any or all of the following reasons:</p><ul>
<li>we don't have to worry about buffer overruns</li>
<li>length sensitive <em>MyStr</em> functions run faster than their standard C counterparts</li>
<li>the required code gets simplified</li>
<li>when it comes to UTF, the related utility-functions can often make our life easier</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
Example 1 (UTF-8)</h2>
<p>UTF-8 guarantees that <code>NUL</code> is a single-byte zero, thus a simple call to <code>strlen()</code> returns the count of bytes of any <code>NUL</code>-terminated UTF-8 string, excluding the <code>NUL</code> itself. In <em>MyStr</em> terms, this means we can often treat UTF-8 strings as <em>c-strings</em>.</p>
<p>In the following C11 snippet, we use <em>MyStr</em>'s <code>ms_cscat()</code> to concatenate a bunch of <code>NUL</code>-terminated UTF-8 strings into an <em>mstring</em>, reading them from an array. The code becomes trivial, and we don't even have to worry about outputting, because <code>printf()</code> takes care of that too (assuming proper compilation flags and system locale). The length and size after each concatenation are purposely shown in the output, verifying that despite the multi-byte encoding nature of UTF-8, our <em>MyStr</em> code works fine.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Since Windows 8 (or Windows 7, not sure), the cmd.exe console is capable of displaying UTF-8 text, after changing its codepage to <em>65001</em> and setting its font to <em>Consolas</em> or <em>Lucida Console</em>. Depending on the compiler, it may also be necessary to have all source-code files saved and compiled as UTF-8. As of this writing, Windows 10 provide improved UTF-8 support as a system Language setting, but it is marked as <b>beta</b>. </p>
</blockquote>
<div class="fragment"><div class="line">MyStr *ms_cscat(MyStr *ms, <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr);   <span class="comment">// Append c-string to mstring.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// UTF-8 Strings Concatenation (C11)</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// lowercase Greek alphabet</span></div>
<div class="line">const <span class="keywordtype">char</span> *u8strings[] = {</div>
<div class="line">    <span class="comment">// regular letters</span></div>
<div class="line">    u8<span class="stringliteral">&quot;αβγδ&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;εζ&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;ηθι&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;κλμνξ&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;ο&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;πρστυφ&quot;</span>,</div>
<div class="line">    u8<span class="stringliteral">&quot;χψω&quot;</span>,</div>
<div class="line">    <span class="comment">// accented vowels</span></div>
<div class="line">    u8<span class="stringliteral">&quot;άέήίϊΐόύϋΰώ&quot;</span>,</div>
<div class="line">    NULL</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u8strings[i]; i++) {</div>
<div class="line">    ms_cscat( ms, u8strings[i] );</div>
<div class="line">    printf( <span class="stringliteral">&quot;%zu/%zu:%s\n&quot;</span>, mslen(ms), mssz(ms), msbuf(ms) );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (8/128):αβγδ</span></div>
<div class="line"><span class="comment">// (12/128):αβγδεζ</span></div>
<div class="line"><span class="comment">// (18/128):αβγδεζηθι</span></div>
<div class="line"><span class="comment">// (28/128):αβγδεζηθικλμνξ</span></div>
<div class="line"><span class="comment">// (30/128):αβγδεζηθικλμνξο</span></div>
<div class="line"><span class="comment">// (42/128):αβγδεζηθικλμνξοπρστυφ</span></div>
<div class="line"><span class="comment">// (48/128):αβγδεζηθικλμνξοπρστυφχψω</span></div>
<div class="line"><span class="comment">// (70/128):αβγδεζηθικλμνξοπρστυφχψωάέήίϊΐόύϋΰώ</span></div>
</div><!-- fragment --><p>Normally, UTF-8 <code>NUL</code>s do not appear in UTF-8 text, so the above approach should always work with valid UTF-8 strings.</p>
<p>To check for a UTF-8 BOM prefix (pretty rear) and optionally skip over it, we may use the utility-function <code>msu_u8pastbom()</code>. See also the <em>Example 2 (UTF-16) &gt;&gt; Bytes Count &amp; BOM</em> section below, which demonstrates the sister function <code>msu_u16pastbom()</code> (the only difference is that after skipping the BOM, subsequent references to the string's length should be decreased by 3 bytes instead of 2).</p>
<p>To deal with UTF-8-"ish" buffers containing multiple <code>NUL</code>s and potentially invalid byte sequences, we simply treat them like any other <em>binary safe memory-buffer</em>, hence keeping track of their total length in bytes (this is usually done while reading them). That's outside the scope of this course, but assuming we've recorded them along with their length into an array <code>u8buffers</code>, we can then concatenate them into an <em>mstring</em> like before, by using <code>ms_mcat()</code> (the <em>binary-safe</em> version of <code>ms_cscat()</code>).</p>
<div class="fragment"><div class="line">MyStr *ms_mcat(MyStr *ms, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> len); <span class="comment">// Append memory-buffer to mstring.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// UTF-8 Buffers Concatenation (C11)</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// array of UTF-8 buffers containing random &#39;\0&#39;s</span></div>
<div class="line">struct {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *data;</div>
<div class="line">    <span class="keywordtype">size_t</span> len;</div>
<div class="line">} u8buffers[] = {</div>
<div class="line">    { u8<span class="stringliteral">&quot;αβ\0γδ&quot;</span>, 9 },</div>
<div class="line">    { u8<span class="stringliteral">&quot;\0εζ\0&quot;</span>, 6 },</div>
<div class="line">    { u8<span class="stringliteral">&quot;ηθι&quot;</span>, 6 },</div>
<div class="line">    { u8<span class="stringliteral">&quot;κλ\0\0μνξ&quot;</span>, 12 },</div>
<div class="line">    { NULL, 0 }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u8buffers[i].data; i++) {</div>
<div class="line">    ms_mcat( ms, u8buffers[i].data, u8buffers[i].len );</div>
<div class="line">    printf( <span class="stringliteral">&quot;(%zu/%zu):&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">    msfdump( ms, 0, <span class="charliteral">&#39;\0&#39;</span>, stdout ); <span class="comment">// instead of printf() which can&#39;t parse multiple zero-bytes</span></div>
<div class="line">    putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (9/128):αβ γδ</span></div>
<div class="line"><span class="comment">// (15/128):αβ γδ εζ</span></div>
<div class="line"><span class="comment">// (21/128):αβ γδ εζ ηθι</span></div>
<div class="line"><span class="comment">// (33/128):αβ γδ εζ ηθικλ  μνξ</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Example 2 (UTF-16)</h2>
<p>UTF-16 "characters" may consist of 1 or more <em>2-byte</em> units. Depending on the endianness, the low or high byte of a unit can be zero. Moreover, UTF-16 <code>NUL</code> is a <em>2-byte</em> zero-unit (0x0000). Thus we can't obtain byte lengths of UTF-16 <code>NUL</code>-terminated strings with <code>strlen()</code>, as we do with UTF-8 strings. In <em>MyStr</em> terms this means we can treat UTF-16 strings as <em>binary safe memory buffers</em>.</p>
<p>Keep also in mind that reading UTF-16 text from a file, will almost always include a BOM prefix indicating the encoded endianness.</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Bytes Count &amp; BOM</h3>
<p>Counting the bytes of a UTF-16 <code>NUL</code>-terminated string including the BOM prefix (if any) is trivial, but <em>MyStr</em> provides the utility-function <code>msu_u16len()</code> anyway. It also provides the utility-function <code>msu_u16pastbom()</code> for optionally skipping the BOM prefix (if any). If a BOM prefix is present, this function returns a pointer past it, else the returned pointer points to the start of the string.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: If the pointer returned by <code>msu_u16pastbom()</code> (let's call it <code>pastbom</code>) does <em>not</em> point to the start of the string, then we <em>know</em> that a BOM prefix was skipped and lies just before <code>pastbom</code>. If so, we should make sure that any further reference to the string via the <code>pastbom</code> pointer goes hand-in-hand with an updated length, reflecting the absence of the BOM prefix (see the code snippet that follows). </p>
</blockquote>
<p>The following C11 code snippet uses those 2 utility-functions to print the bytes of a UTF-16 <code>NUL</code>-terminated string-literal as hex values, with and without checking for a BOM prefix. There are no <em>mstrings</em> involved here (just to emphasize that neither function is <em>mstring</em> specific). Note the UTF-16 string-literal initialization via C11's <code>u</code> prefix, along with its casting to <code>char *</code>. Note also that after checking for BOM, the length is updated accordingly. On a last note, hard-coding the BOM into the string-literal is done <b>only</b> for demo'ing <code>msu_u16pastbom()</code> quickly in this particular example; we should <b>not</b> do it in real code.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> msu_u16len( <span class="keyword">const</span> <span class="keywordtype">void</span> *u16str );    <span class="comment">// UTF-16 bytes count excluding NUL-termination.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">char</span> *msu_u16pastbom( <span class="keyword">const</span> <span class="keywordtype">void</span> *u16str ); <span class="comment">// Past BOM pointer of a UTF-16 string.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Bytes Length of UTF-16 NUL-terminated String (C11)</span></div>
<div class="line"><span class="comment">// (on my platform UTF-16 literals are LE, they may be BE on yours)</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// hard-coded BOM just for quick demo (DO NOT do it in your code)</span></div>
<div class="line">const <span class="keywordtype">char</span> *u16str = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) u<span class="stringliteral">&quot;\xFFFEklmn&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> len = msu_u16len( u16str );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXPECTED OUTPUT: Full (10 bytes): FE FF 6B 00 6C 00 6D 00 6E 00</span></div>
<div class="line">printf( <span class="stringliteral">&quot;Full (%zu bytes): &quot;</span>, len );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; len; i++) {</div>
<div class="line">    printf( <span class="stringliteral">&quot;%02X &quot;</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)u16str)[i] );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXPECTED OUTPUT: w/o BOM (8 bytes): 6B 00 6C 00 6D 00 6E 00</span></div>
<div class="line"><span class="keywordtype">char</span> *pastbom = msu_u16pastbom( u16str );   <span class="comment">// get past BOM pointer</span></div>
<div class="line"><span class="keywordflow">if</span> ( pastbom != u16str ) {                  <span class="comment">// if necessary, update len</span></div>
<div class="line">    len -= 2;       <span class="comment">// &lt;--- UTF-16 BOM is always 2-byte long</span></div>
<div class="line">}</div>
<div class="line">printf( <span class="stringliteral">&quot;w/o BOM (%zu bytes): &quot;</span>, len );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; len; i++) {</div>
<div class="line">    <span class="comment">// using pastbom-pointer instead of u16str</span></div>
<div class="line">    printf( <span class="stringliteral">&quot;%02X &quot;</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)pastbom)[i] );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">...</div>
</div><!-- fragment --><p>If for some reason there are multiple consecutive BOM prefixes, we can use <code>msu_u16pastbom()</code> in a loop to skip over all of them (the same is true for the functions <code>msu_u8pastbom()</code> and <code>msu_u32pastbom()</code>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// artificially inserted BOM sequences (DO NOT do it in your code)</span></div>
<div class="line">const <span class="keywordtype">char</span> *u16str = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) u<span class="stringliteral">&quot;\xFFFE\xFFFE\xFFFE\xFFFEklmn&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> len = msu_u16len( u16str );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXPECTED OUTPUT: Full (16 bytes): FE FF FE FF FE FF FE FF 6B 00 6C 00 6D 00 6E 00</span></div>
<div class="line">printf( <span class="stringliteral">&quot;Full (%zu bytes): &quot;</span>, len );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; len; i++) {</div>
<div class="line">    printf( <span class="stringliteral">&quot;%02X &quot;</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)u16str)[i] );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXPECTED OUTPUT: (4 consecutive BOM skipped)</span></div>
<div class="line"><span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><span class="keywordtype">char</span> *pastbom = NULL;</div>
<div class="line"><span class="keywordtype">char</span> *prebom = (<span class="keywordtype">char</span> *)u16str;</div>
<div class="line"><span class="keywordflow">while</span> ( prebom != (pastbom = msu_u16pastbom(prebom)) ) {</div>
<div class="line">    prebom = pastbom;</div>
<div class="line">    i++;</div>
<div class="line">}</div>
<div class="line">printf( <span class="stringliteral">&quot;(%zu consecutive BOM skipped)\n&quot;</span>, i );</div>
<div class="line"> </div>
<div class="line">len -= (2 * i); <span class="comment">// update length : faster than using msu_u16len( pastbom );</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXPECTED OUTPUT: w/o BOM (8 bytes): 6B 00 6C 00 6D 00 6E 00</span></div>
<div class="line">printf( <span class="stringliteral">&quot;w/ BOM (%zu bytes): &quot;</span>, len );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; len; i++) {</div>
<div class="line">    <span class="comment">// using pastbom-pointer instead of u16str</span></div>
<div class="line">    printf( <span class="stringliteral">&quot;%02X &quot;</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)pastbom)[i] );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
</div><!-- fragment --><p><code>msu_u16pastbom()</code> works with both big-endian and little-endian UTF-16 BOM prefixes (<code>"\xFE\xFF"</code> and <code>"\xFF\xFE"</code>, respectively).</p>
<p>To check for a specific BOM prefix, we can use <code>msu_pastprefix()</code> instead, which generalizes the functionality to any byte sequences for <em>buffer</em> and <em>prefix</em>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *msu_pastprefix( <span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keyword">const</span> <span class="keywordtype">void</span> *prefix, <span class="keywordtype">size_t</span> lenprefix );</div>
</div><!-- fragment --><p>Furthermore, <em>MyStr</em> also provides preprocessor constants for all UTF-8/16/32 BOM prefixes, in the header file mystr.h.</p>
<p>For UTF-16 they are called:</p><ul>
<li><code>MS_U16BE_BOM</code> (big-endian)</li>
<li><code>MS_U16LE_BOM</code> (little-endian)</li>
</ul>
<p>Thus, if we wanted to check just for the big-endian BOM in the previous example, we would have changed the loop condition, as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//while ( prebom != (pastbom = msu_u16pastbom(prebom)) ) {</span></div>
<div class="line"><span class="keywordtype">size_t</span> bomlen = strlen( MS_U16BE_BOM );</div>
<div class="line"><span class="keywordflow">while</span> ( prebom != (pastbom = msu_pastprefix(prebom, MS_U16BE_BOM, bomlen)) ) {</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
Concatenating</h3>
<p>Putting BOM aside for a second, using <em>mstrings</em> along with <code>msu_u16len()</code> and <code>ms_mcat()</code> makes it trivial to concatenate UTF-16 <code>NUL</code>-terminated strings. Outputting the UTF-16 result as readable text to the terminal is a little more tricky, so for now we'll use <code>msfdump()</code> in hex-mode with a dash separator between bytes (we'll cover human readable text a little later).</p>
<p>To prove a point, we'll use uppercase English letters because they contain single-byte zeros as part of their UTF-16 encoding. Still, our <em>MyStr</em> concatenation will work as expected.</p>
<p>Also, instead of casting our UTF-16 string-literals to <code>char *</code> during initialization, this time we'll declare and leave them as <code>uint16_t *</code>, being consistent with the 16-bit unit nature of C11's <code>u</code> prefix. <em>MyStr</em> works either way, because <code>ms_mcat()</code> and <code>msu_u16len()</code> cast anyway their <code>void *</code> argument to a flat buffer of consecutive bytes.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: The accurate data type of UTF-16 encoded string-literals in C11 (denoted with the <code>u</code> prefix) is <code>char16_t *</code>, and it is identical to C99 <code>uint_least16_t *</code>. However, <code>char16_t</code> may be larger than 16 bits. On some exotic platforms <code>uint16_t</code> may not exist. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// UTF-16 Strings Concatenation (C11) - Without BOM Checking</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span> <span class="comment">// for uint16_t</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// uppercase English letters in UTF-16</span></div>
<div class="line">const uint16_t *u16strings[] = {</div>
<div class="line">    u<span class="stringliteral">&quot;ABCD&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;EF&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;GHI&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;JKLMN&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;O&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;PQRSTU&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;VWXYZ&quot;</span>,</div>
<div class="line">    NULL</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u16strings[i]; i++) {</div>
<div class="line">    ms_mcat( ms, u16strings[i], msu_u16len(u16strings[i]) );</div>
<div class="line"> </div>
<div class="line">    printf( <span class="stringliteral">&quot;(%zu/%zu):\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">    msfdump( ms, 16, <span class="charliteral">&#39;-&#39;</span>, stdout );</div>
<div class="line">    puts( <span class="stringliteral">&quot;\n&quot;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (8/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (12/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (18/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (28/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (30/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (42/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00-50-00-51-00-52-00-53-00-54-00-55-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (52/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00-50-00-51-00-52-00-53-00-54-00-55-00-56-00-57-00-58-00-59-00-5A-00</span></div>
</div><!-- fragment --><p>Adding BOM checking and skipping is also trivial, keeping the code small and simple. Note though that we do cast <code>u16strings[i]</code> to <code>char *</code> when comparing it with <code>pastbom</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// UTF-16 Strings Concatenation (C11) - With BOM Checking</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span> <span class="comment">// for uint16_t</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// uppercase English letters in UTF-16</span></div>
<div class="line">const uint16_t *u16strings[] = {</div>
<div class="line">    u<span class="stringliteral">&quot;\xFFFE&quot;</span> u<span class="stringliteral">&quot;ABCD&quot;</span>,  <span class="comment">// hard-coded BOM (DO NOT do it in your code)</span></div>
<div class="line">    u<span class="stringliteral">&quot;EF&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;GHI&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;JKLMN&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;O&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;PQRSTU&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;\xFFFE&quot;</span> u<span class="stringliteral">&quot;VWXYZ&quot;</span>, <span class="comment">// hard-coded BOM (DO NOT do it in your code)</span></div>
<div class="line">    NULL</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u16strings[i]; i++) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// discard BOM-prefix if any</span></div>
<div class="line">    <span class="keywordtype">size_t</span> len = msu_u16len( u16strings[i] );</div>
<div class="line">    <span class="keywordtype">char</span> *pastbom = msu_u16pastbom( u16strings[i] );</div>
<div class="line">    <span class="keywordflow">if</span> ( pastbom != (<span class="keywordtype">char</span> *)u16strings[i] ) {</div>
<div class="line">        len -= 2;</div>
<div class="line">    }</div>
<div class="line">    ms_mcat( ms, pastbom, len );    <span class="comment">// using pastbom instead of u16strings[i]</span></div>
<div class="line"> </div>
<div class="line">    printf( <span class="stringliteral">&quot;(%zu/%zu):\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">    msfdump( ms, 16, <span class="charliteral">&#39;-&#39;</span>, stdout );</div>
<div class="line">    puts( <span class="stringliteral">&quot;\n&quot;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (8/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// (52/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00-50-00-51-00-52-00-53-00-54-00-55-00-56-00-57-00-58-00-59-00-5A-00</span></div>
</div><!-- fragment --><p>code snippet shows a custom function to calculate the bytes length of a UTF-16 <code>NUL</code>-terminated string, excluding the UTF-16 <code>NUL</code>-terminator. Assuming of course that no UTF-16 <code>NUL</code>s exist anywhere else in the string, but remember that non-consecutive single-byte zeros may very well exist, since they are part of the encoding itself.</p>
<p>The following C11 code shows a custom function to calculate the bytes length of a UTF-16 <code>NUL</code>-terminated string, excluding the UTF-16 <code>NUL</code>-terminator. Assuming of course that no UTF-16 <code>NUL</code>s exist anywhere else in the string, but remember that non-consecutive single-byte zeros may very well exist, since they are part of the encoding itself.</p>
<div class="fragment"><div class="line"><span class="comment">// Count UTF-16 String Bytes, Excluding NUL-termination (C11)</span></div>
<div class="line"><span class="comment">// NOTE: My C11 compiler currently lacks &lt;uchar.h&gt;, so I&#39;m using</span></div>
<div class="line"><span class="comment">// C99 uint_least16_t instead of char16_t (they&#39;re identical types).</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span>     <span class="comment">// uint_least16_t, etc</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ----------------------------------------</span></div>
<div class="line"><span class="comment">// Return count of bytes in a UTF-16 NUL-terminated string, excluding NUL.</span></div>
<div class="line"><span class="comment">// NOTES: UTF-16 NUL is 0x0000, same as u&quot;&quot; or u&#39;\0&#39;. The func stops at the</span></div>
<div class="line"><span class="comment">// first NUL found, any further NULs are ignored.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> u16str_byteslen( <span class="keyword">const</span> uint_least16_t *u16str )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> uint_least16_t u16nul[] = u<span class="stringliteral">&quot;&quot;</span>;    <span class="comment">// u prefix guarantees utf-16 literal (C11)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> nulsz = <span class="keyword">sizeof</span>( u16nul );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bytep = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)u16str;</div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">        <span class="keywordflow">if</span> ( 0 == memcmp(bytep, u16nul, nulsz) ) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        bytep += <span class="keyword">sizeof</span>( *u16str );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)(bytep - (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)u16str) ;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ----------------------------------------</span></div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    uint_least16_t u16str[] = u<span class="stringliteral">&quot;ABC&quot;</span>;   <span class="comment">// u prefix guarantees utf-16 literal (C11)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// verify u16str_byteslen() against sizeof</span></div>
<div class="line">    printf( <span class="stringliteral">&quot;sizeof: %zu\nbyteslen: %zu\n&quot;</span>, <span class="keyword">sizeof</span>(u16str), u16str_byteslen(u16str) );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// show u16str bytes in hex</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <span class="keyword">sizeof</span>(u16str); i++) {</div>
<div class="line">        printf( <span class="stringliteral">&quot;%02X &quot;</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;u16str)[i] );</div>
<div class="line">    }</div>
<div class="line">    putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">sizeof: 8</div>
<div class="line">byteslen: 6</div>
<div class="line">41 00 42 00 43 00 00 00</div>
</div><!-- fragment --><p>Since we can now correctly calculate the bytes length of UTF-16 <code>NUL</code>-terminated strings excluding <code>NUL</code> itself, concatenating them into an <em>mstring</em> becomes again a trivial task, by using <code>ms_mcat()</code>. Using plain C to output UTF-16 strings to the terminal though is a different story, and again it's outside the scope of this course. We'll just use <code>msfdump()</code> in hex-mode, with a dash separator between bytes.</p>
<div class="fragment"><div class="line"><span class="comment">// UTF-16 Strings Concatenation (C11)</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// uppercase English alphabet in UTF-16</span></div>
<div class="line">const uint_least16_t *u16strings[] = {</div>
<div class="line">    u<span class="stringliteral">&quot;ABCD&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;EF&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;GHI&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;JKLMN&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;O&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;PQRSTU&quot;</span>,</div>
<div class="line">    u<span class="stringliteral">&quot;VWXYZ&quot;</span>,</div>
<div class="line">    NULL</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u16strings[i]; i++) {</div>
<div class="line">    ms_mcat( ms, u16strings[i], u16str_byteslen(u16strings[i]) );</div>
<div class="line">    printf( <span class="stringliteral">&quot;(%zu/%zu):\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">    msfdump( ms, 16, <span class="charliteral">&#39;-&#39;</span>, stdout );</div>
<div class="line">    puts( <span class="stringliteral">&quot;\n&quot;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (8/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (12/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (18/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (28/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (30/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (42/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00-50-00-51-00-52-00-53-00-54-00-55-00</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// (52/128):</span></div>
<div class="line"><span class="comment">// 41-00-42-00-43-00-44-00-45-00-46-00-47-00-48-00-49-00-4A-00-4B-00-4C-00-4D-00-4E-00-4F-00-50-00-51-00-52-00-53-00-54-00-55-00-56-00-57-00-58-00-59-00-5A-00</span></div>
</div><!-- fragment --><p>By examining the output of the above snippet, it becomes clear that all uppercase English letters contain single-byte zeros as part of their UTF-16 encoding. Still our <em>MyStr</em> concatenation works as expected.</p>
<p>If the strings are not meant to change once they are read, we can record them along with their length into a <em>u16buffers</em> array and refrain from using <code>u16str_byteslen()</code> in the concatenation loop. This can be simulated in our simplified example by initializing that array, like we did in the 2nd UTF-8 example, above.</p>
<div class="fragment"><div class="line"><span class="comment">// UTF-16 Strings Concatenation (C11)</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// uppercase English alphabet in UTF-16</span></div>
<div class="line">struct {</div>
<div class="line">    <span class="keyword">const</span> uint_least16_t *data;</div>
<div class="line">    <span class="keywordtype">size_t</span> len;</div>
<div class="line">} u16buffers[] = {</div>
<div class="line">    { u<span class="stringliteral">&quot;ABCD&quot;</span>,   u16str_byteslen(u<span class="stringliteral">&quot;ABCD&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;EF&quot;</span>,     u16str_byteslen(u<span class="stringliteral">&quot;EF&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;GHI&quot;</span>,    u16str_byteslen(u<span class="stringliteral">&quot;GHI&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;JKLMN&quot;</span>,  u16str_byteslen(u<span class="stringliteral">&quot;JKLMN&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;O&quot;</span>,      u16str_byteslen(u<span class="stringliteral">&quot;O&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;PQRSTU&quot;</span>, u16str_byteslen(u<span class="stringliteral">&quot;PQRSTU&quot;</span>) },</div>
<div class="line">    { u<span class="stringliteral">&quot;VWXYZ&quot;</span>,  u16str_byteslen(u<span class="stringliteral">&quot;VWXYZ&quot;</span>) },</div>
<div class="line">    { NULL,      0 }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyStr *ms = msnew(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; u16buffers[i].data; i++) {</div>
<div class="line">    ms_mcat( ms, u16buffers[i].data, u16buffers[i].len );</div>
<div class="line">    printf( <span class="stringliteral">&quot;(%zu/%zu):\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">    msfdump( ms, 16, <span class="charliteral">&#39;-&#39;</span>, stdout );</div>
<div class="line">    puts( <span class="stringliteral">&quot;\n&quot;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md36"></a>
Header 1</h1>
<h2><a class="anchor" id="autotoc_md37"></a>
Header 2</h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

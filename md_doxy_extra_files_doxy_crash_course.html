<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MSUTimer: Crash Course</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MSUTimer
   &#160;<span id="projectnumber">v0.01 alpha</span>
   </div>
   <div id="projectbrief">Simple High Resolution Timer for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doxy_extra_files_doxy_crash_course.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Crash Course </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p><em>MyStr</em> is a C99 compliant convenience library, for basic dynamic string handling. The main goal is to reduce the risk of buffer overflows, and make it easier to handle binary-safe strings. It is by no means a replacement for <code>&lt;string.h&gt;</code>, but rather a little complement on the side.</p>
<p>The library does excessive error-checking, so it may not be suitable for resource critical applications and restrained exotic platforms. That said, speed-wise, <em>MyStr</em> user code relying on string lengths should outperform <code>&lt;string.h&gt;</code>-based alternatives. The bigger the strings, the bigger the gain.</p>
<p>The <b>basis</b> of <em>MyStr</em> is a private <code>struct</code> data type, publicly exposed as <code>MyStr</code> via the <code>mystr.h</code> header file.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_MyStr {</div>
<div class="line">    <span class="keywordtype">size_t</span> len;</div>
<div class="line">    <span class="keywordtype">size_t</span> size;</div>
<div class="line">    <span class="keywordtype">char</span> *buf;</div>
<div class="line">} MyStr;</div>
</div><!-- fragment --><p>In user code, <em>MyStr</em> strings (<em>mstrings</em> from now on, for brevity) are declared as pointers to <code>MyStr</code>. Instantiated <em>mstrings</em> are always null-terminated and binary-safe (see <em>Binary Safeness</em>, further below).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = NULL;   <span class="comment">// non-dangling definition of an mstring</span></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md2"></a>
Installation &amp; Dependencies</h1>
<blockquote class="doxtable">
<p><b>First and foremost</b>, the <em>MyStr</em> library should always get compiled as <b>C99</b> or later, else it is open to unpredictable behavior. For example, the library uses <code>snprintf()</code> whose behavior was not consistent across different platforms before C99 (thankfully, nowadays it is implemented according to the C99 specification almost everywhere). </p>
</blockquote>
<p>The library consists of just 2 files: mystr.h (public interface) and <b>mystr.c</b> (private implementation).</p>
<p>There are no binary distributions, no cmake configurations, not even a makefile. <em>MyStr</em> is way too simple for that kind of nuisance. It does have a couple of configuration preprocessor directives though:</p>
<ul>
<li><p class="startli"><code>MSDEBUG</code> for debug builds (see also <em>Error Handling &amp; Debugging</em>, further below).</p>
<p class="startli">When compiled with the <code>-DMSDEBUG</code> or <code>-DMSDEBUG=1</code> compiler flag, <em>MyStr</em> emits descriptive error-messages to <code>stderr</code>, without stopping the flow of the program. We may compile it with <code>-DMSDEBUG=2</code> instead, if we want our program to exit immediately after the error-message.</p>
</li>
<li><code>MSICONV</code> for enabling a few initially <em>muted</em> utility-functions which rely on the non-standard <a href="https://en.wikipedia.org/wiki/Iconv#Implementations">iconv library</a> (see also <em>Core/Utility Namespaces</em>, further below). <blockquote class="doxtable">
<p><a href="https://en.wikipedia.org/wiki/Iconv#Implementations"><em>libiconv</em></a> is a small and popular POSIX compliant library, widely available in almost every gcc toolchain, including MinGW/MSYS and Cygwin on Windows (there are also Windows specific ports for use with Microsoft's VC/C++ - try googling "libiconv for windows"). </p>
</blockquote>
</li>
</ul>
<p>In this section we assume a gcc toolchain, but it should be easy to adjust the commands for any C99 compiler. Ideally <em>MyStr</em> should be built into a reusable library file. Most readers of this document should already know how to do that in their preferred environment, so here we'll cover only a couple of introductory-level alternatives. Just for presenting those few <em>MyStr</em> compilation options.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Quick &amp; Dirty</h2>
<p>The most straight-forward way of using <em>MyStr</em> is by copying both its files alongside our project source(s), then adding <code>include "mystr.h"</code> at the top of the project's main module and lastly including <b>mystr.c</b> in the project compilation. For debug builds, we can have it emitting error-messages to <code>stderr</code> and optionally exit immediately, via the <code>MSDEBUG</code> preprocessor directive.</p>
<div class="fragment"><div class="line"><span class="comment">// myproj Release build (-O2 is an optional gcc optimization level)</span></div>
<div class="line">gcc -std=c99 -O2 mystr.c myproj.c -o myproj (or -o myproj.exe on Windows)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproj Debug build (without exiting on errors)</span></div>
<div class="line">gcc -std=c99 -DMSDEBUG -g3 -Wall -Wextra mystr.c myproj.c -o myproj</div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproj Debug build (exiting on errors)</span></div>
<div class="line">gcc -std=c99 -DMSDEBUG=2 -g3 -Wall -Wextra mystr.c myproj.c -o myproj</div>
</div><!-- fragment --><p>If <em>libconv</em> is available, we can enable the muted <em>MyStr</em> functions by defining the <code>MSICONV</code> preprocessor directive during compilation, <b>and additionally</b> linking against <em>libiconv</em>:</p>
<div class="fragment"><div class="line"><span class="comment">/* WHEN libconv IS AVAILABLE */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproj Release build</span></div>
<div class="line">gcc -std=c99 -O2 -DMSICONV mystr.c myproj.c -o myproj -liconv</div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproj Debug build (without exiting on errors)</span></div>
<div class="line">gcc -std=c99 -DMSICONV -DMSDEBUG -g3 -Wall -Wextra mystr.c myproj.c -o myproj -liconv</div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproj Debug build (exiting on errors)</span></div>
<div class="line">gcc -std=c99 -DMSICONV -DMSDEBUG=2 -g3 -Wall -Wextra mystr.c myproj.c -o myproj -liconv</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Build Once, Reuse on Demand</h2>
<p>A more flexible alternative would be to compile <em>MyStr</em> once into a reusable <b>object file</b> (or even better, a library file), and then use that on demand:</p>
<div class="fragment"><div class="line"><span class="comment">/* MyStr object-file WHEN libconv IS NOT AVAILABLE */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release version: mystr.o</span></div>
<div class="line">gcc -std=c99 -O2 -c mystr.c -o mystr.o</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug version (without exiting on errors): mystrdbg.o</span></div>
<div class="line">gcc -std=c99 -DMSDEBUG -g3 -Wall -Wextra -c mystr.c -o mystrdbg.o</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug version (exiting on errors): mystrdbgX.o</span></div>
<div class="line">gcc -std=c99 -DMSDEBUG=2 -g3 -Wall -Wextra -c mystr.c -o mystrdbgx.o</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* MyStr object-file WHEN libconv IS AVAILABLE */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release version (mystr.o)</span></div>
<div class="line">gcc -std=c99 -O2 -DMSICONV -c mystr.c -o mystr.o -liconv</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug version (without exiting on errors): mystrdbg.o</span></div>
<div class="line">gcc -std=c99 -DMSICONV -DMSDEBUG -g3 -Wall -Wextra -c mystr.c -o mystrdbg.o -liconv</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug version (exiting on errors): mystrdbgX.o</span></div>
<div class="line">gcc -std=c99 -DMSICONV -DMSDEBUG=2 -g3 -Wall -Wextra -c mystr.c -o mystrdbgX.o -liconv</div>
</div><!-- fragment --><p>We can then link the desired <em>Mystr</em> object-file to any project:</p>
<div class="fragment"><div class="line"><span class="comment">// myproj Release version</span></div>
<div class="line">gcc [whatever flags you want here] mystr.o myproj.c -o myproj  <span class="comment">// or -o myproj.exe on Windows</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproject Debug version (without exiting on errors)</span></div>
<div class="line">gcc [whatever flags you want here] mystrdbg.o myproj.c -o myproj</div>
<div class="line"> </div>
<div class="line"><span class="comment">// myproject Debug version (exiting on errors)</span></div>
<div class="line">gcc [whatever flags you want here] mystrdbgX.o myproj.c -o myproj</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md6"></a>
Core/Utility Namespaces</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Core Functions</h2>
<p>All <em>MyStr</em> core-functions take an <em>mstring</em> as their 1st argument. Their namespace-prefix is <code>ms</code></p>
<p>When a 2nd argument is expected as a <b>source</b> for the <em>mstring</em> (1st argument), the namespace-prefix changes to <code>ms_</code> along with an additional subspace indicator for the expected type of the source.</p>
<blockquote class="doxtable">
<p>This is not a hard rule, but rather a convention followed as much as possible. There are quite a few exceptions, mostly to avoid very long names, or to keep them closer to their standard C counterparts. For example, the getter <code>msiget()</code>, the setter <code>msiset()</code> or the basic constructors <code>msnew()</code> and <code>msmake()</code>are notable exceptions to that convention. </p>
</blockquote>
<p>Here is a list of common namespace-prefixes for <em>MyStr</em> core-functions:</p>
<ul>
<li><code>ms</code>: The 2nd argument is either an <em>mstring</em> source, or not an input source at all.</li>
<li><code>ms_cs</code>: The 2nd argument is a <em>c-string</em> source (null-terminated <code>char</code>-array).</li>
<li><code>ms_f</code>: The 2nd argument is a <em>file-stream</em> source.</li>
<li><code>ms_m</code>: The 2nd argument is a binary safe <em>memory-buffer</em> source (byte-array, possibly containing multiple null-<code>char</code>s and not necessarily null-terminated - its length is passed to the function as an extra argument).</li>
</ul>
<p>The following is an example of 4 core-functions doing similar jobs, using different source buffer types. They append their 2nd argument to the destination <em>mstring</em> (1st argument).</p>
<div class="fragment"><div class="line">MyStr *mscat( MyStr *ms1, <span class="keyword">const</span> MyStr *ms2 );               <span class="comment">// 2nd argument is an mstring (ms2)</span></div>
<div class="line">MyStr *ms_cscat( MyStr *ms, <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr );             <span class="comment">// 2nd argument is a c-string (cstr)</span></div>
<div class="line">MyStr *ms_mcat( MyStr *ms, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> len );   <span class="comment">// 2nd argument is a memory-buffer (buf)</span></div>
<div class="line">MyStr *ms_fcat( MyStr *ms, FILE *fp, <span class="keywordtype">size_t</span> len );          <span class="comment">// 2nd argument is a file stream (fp)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Utility Functions</h2>
<p>As a little bonus, the library also provides some utility-functions, which are <b>not</b> <em>mstring</em> specific (there is no <em>mstring</em> in their argument list). Thus they are not essential to <em>MyStr</em>'s main functionality. However, besides being used as is, they can also be used as building blocks for custom functions operating on <em>mstrings</em>. Their namespace prefix is <code>msu_</code></p>
<p>Here's some examples:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *msu_strdup( <span class="keyword">const</span> <span class="keywordtype">char</span> *str );            <span class="comment">// Similar to POSIX strdup() but w/ error checks &amp; reporting</span></div>
<div class="line"><span class="keywordtype">size_t</span> msu_u16len( <span class="keyword">const</span> <span class="keywordtype">void</span> *u16str );        <span class="comment">// Bytes-length of a UTF-16 string.</span></div>
<div class="line"><span class="keywordtype">char</span> *msu_u16pastbom( <span class="keyword">const</span> <span class="keywordtype">void</span> *u16str );     <span class="comment">// Past BOM pointer to a UTF-16 string.</span></div>
<div class="line"><span class="keywordtype">char</span> *msu_u8pastbom( <span class="keyword">const</span> <span class="keywordtype">void</span> *u8str );       <span class="comment">// Past BOM pointer to a UTF-8 string.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// UTF-16 to UTF-8 (needs libiconv)</span></div>
<div class="line"><span class="keywordtype">char</span> *msu_u8alloc_from_u16( <span class="keyword">const</span> <span class="keywordtype">char</span> *u16src, <span class="keywordtype">size_t</span> u16len, <span class="keyword">const</span> <span class="keywordtype">char</span> *u16code, <span class="keywordtype">size_t</span> *reslen );</div>
<div class="line"><span class="comment">// UTF-8 to UTF-16 (needs libiconv)</span></div>
<div class="line"><span class="keywordtype">char</span> *msu_u16alloc_from_u8( <span class="keyword">const</span> <span class="keywordtype">char</span> *u16code, <span class="keyword">const</span> <span class="keywordtype">char</span> *u8src, <span class="keywordtype">size_t</span> u8len, <span class="keywordtype">size_t</span> *reslen );</div>
</div><!-- fragment --><p>Not all utility-functions will be available on all platforms. For example, the <b>last 2</b> shown above depend on the POSIX <em>libiconv</em> library, which is external to <em>MyStr</em> (see also <em>Installation &amp; Dependencies</em>, above).</p>
<blockquote class="doxtable">
<p>As of this writing, <em>libiconv</em> is the only external dependency, affecting just a handful of bonus functions that are not <em>mstring</em> aware anyway. Without <em>libiconv</em> these very few functions will simply stop being functional. </p>
</blockquote>
<hr  />
 <h1><a class="anchor" id="autotoc_md10"></a>
Sizes</h1>
<p>For reasonable speed/space efficiency trade-off on average usage, <em>MyStr</em> takes a power-of-2 alloc-ahead approach.</p>
<p>More specifically, when an <em>mstring</em> is first created its allocated size (in bytes) equals to the least power of 2 that is greater than the needed size, including null-termination. Thus <em>mstring</em> lengths are usually much less than their actual allocated size. When the allocated size gets exhausted, it doubles itself (see also <em>Size Limits</em>, below).</p>
<p>While it is possible to manually truncate or grow the allocated size, it is not generally recommended (nevertheless, see also <em>Size Adjustments</em>, below).</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Size Limits</h2>
<p>The <b>minimum</b> allocated size per <em>mstring</em> is <code>MS_ALLOCSZ_MIN</code> bytes, set by default at 128 in the public header mystr.h. We may change it but we <b>must always keep it at a power of 2</b>, because internally <em>MyStr</em> depends heavily on that assumption.</p>
<p>The <b>maximum</b> allocated size per <em>mstring</em> is (1+<code>SIZE_MAX</code>/2). <code>SIZE_MAX</code> is an implementation dependent constant defined in <code>&lt;stddef.h&gt;</code> (and other standard header files). It usually equals to the maximum unsigned value fitting into a 32/64-bit word. If for example, <code>SIZE_MAX</code> is 4294967295 bytes on our system, no <em>mstring</em> will ever have an allocated size greater than 2147483648 bytes. We can use the utility-function <code>msu_maxsz()</code> to get the exact value on our platform.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Length vs. Size</h2>
<p>All <em>mstrings</em> are implicitly null-terminated, but they may also contain multiple null-bytes. Which of those null-bytes (if any) flags the current length of an <em>mstring</em> depends on the <em>MyStr</em> functions we handle the <em>mstring</em> with. For example, all functions in the <code>ms_m</code> namespace allow embedded null-bytes, while all functions in the <code>ms_cs</code> namespace do not (see also <em>Binary Safeness</em>, below).</p>
<p>In any case, the current <b>length</b> is always less than the allocated <b>size</b>. Fetching these values is an <b>O(1)</b> operation, via the functions <code>mslen()</code> and <code>mssz()</code>, respectively.</p>
<p>Note that <code>mslen()</code> does not count the null-terminator, and in most cases <code>mssz()</code> does not equal to <code>mslen()</code>+1.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> mslen( <span class="keyword">const</span> MyStr *ms );</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">size_t</span> mssz( <span class="keyword">const</span> MyStr *ms );</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line">printf( <span class="stringliteral">&quot;%zu/%zu\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// 12/128</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Size Adjustments</h2>
<p>The extra alloc-ahead space beyond the null-termination may seem like a waste, but it's actually a justified trade-off. It can speed up dramatically important operations (like concatenation for example) by sparing us expensive re-allocations.</p>
<p>If used memory is an issue, we may <b>truncate</b> the allocated space of any <em>mstring</em> to its minimal required size via <code>mstrunc()</code>. However, further calls to functions like <code>mscat()</code>, <code>mscpy()</code>, etc, may snap it back to <code>MS_ALLOCSZ_MIN</code> if need be, or to its next power of 2 for longer strings. So we should keep that in mind.</p>
<div class="fragment"><div class="line">MyStr *mstrunc( MyStr *ms );    <span class="comment">// Truncate mstring&#39;s excessive allocated size.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line">mstrunc( ms );</div>
<div class="line">printf( <span class="stringliteral">&quot;%zu/%zu\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// 12/13</span></div>
</div><!-- fragment --><p>We can also <b>grow</b> the allocated size of an <em>mstring</em> via <code>msgrow()</code>. This function takes the desired max length (in bytes) as an argument, and re-allocates the <em>mstring</em> accordingly <b>reserving 1 extra byte</b> for the implicit null-termination.</p>
<p>It can help in reducing the needed re-allocations when adding data to an <em>mstring</em>. Suppose we start with an empty <em>mstring</em>, but we know it will eventually need room for at least 64K bytes. No <em>MyStr</em> constructor allows us to randomly define a pre-allocation size. Using <code>msnew()</code> for example to create the empty <em>mstring</em>, we get an initially allocated size of <code>MS_ALLOCSZ_MIN</code> bytes (128 by default), which doubles itself as needed. To gradually fill the <em>mstring</em> with 64k bytes worth of data, in the worst case it would take 10 (re)allocations, including the construction.</p>
<p>We can dial that down to a fixed count of just 2 total (re)allocations, using <code>msgrow()</code>:</p>
<div class="fragment"><div class="line">MyStr *msgrow( MyStr *ms, <span class="keywordtype">size_t</span> maxlen );  <span class="comment">// Grow the allocated size of an mstring.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">printf( <span class="stringliteral">&quot;%zu/%zu\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line"> </div>
<div class="line">msgrow( ms, 64*1024 - 1 );  <span class="comment">// -1 due to the implicit +1 for null-termination (else we&#39;d get 128K)</span></div>
<div class="line">printf( <span class="stringliteral">&quot;%zu/%zu\n&quot;</span>, mslen(ms), mssz(ms) );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// 0/128</span></div>
<div class="line"><span class="comment">// 0/65536</span></div>
</div><!-- fragment --><p>Keep in mind that <code>msgrow()</code> does not extend the size blindly. It always snaps it to the closest largest power of 2, including the extra byte for null-termination. Thus, even if we had specified 60K in the above example, the function would have allocated 64K. Moreover, the extended size will never be less than <code>MS_ALLOCSZ_MIN</code>.</p>
<blockquote class="doxtable">
<p><code>msgrow()</code> guarantees that the <em>mstring</em> size gets always snapped to its closest largest power of 2, equal to at least <code>MS_ALLOCSZ_MIN</code>. </p>
</blockquote>
<p>On a final note, if the requested max length is less than the currently allocated capacity, there will be no growing <b>unless</b> the <em>mstring</em> size was previously truncated to a non power of 2, via <code>mstrunc()</code>. In that case, the <em>mstring</em> size will nevertheless grow to its closest largest power of 2 (or to <code>MS_ALLOCSZ_MIN</code> if it was less due to truncation).</p>
<blockquote class="doxtable">
<p><b>TIP</b>: <code>msgrow(ms,0)</code> is a quick way to kinda cancel the effect of <code>mstrunc(ms)</code> </p>
</blockquote>
<p>To illustrate this, consider the following example. First we create a small 2-bytes <em>mstring</em> (+1 for null-terminator). Its initial allocated size equals to the minimum possible, that is <code>MS_ALLOCSZ_MIN</code> (128 by default). We then truncate it, thus its allocated size goes down to 3 bytes, which is not only less than <code>MS_ALLOCSZ_MIN</code> but also it's not a power of 2. Lastly, just for the sake of the example, we request it to grow to a max length of just 1 byte. Obviously 1 (+1 for null-termination) is less than the current size (3), but nevertheless <code>msgrow()</code> snaps it back to <code>MS_ALLOCSZ_MIN</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;ab&quot;</span>);</div>
<div class="line">printf( <span class="stringliteral">&quot;(%zu/%zu):%s\n&quot;</span>, mslen(ms), mssz(ms), msbuf(ms) );</div>
<div class="line"> </div>
<div class="line">mstrunc( ms );</div>
<div class="line">printf( <span class="stringliteral">&quot;(%zu/%zu):%s\n&quot;</span>, mslen(ms), mssz(ms), msbuf(ms) );</div>
<div class="line"> </div>
<div class="line">msgrow( ms, 1 );</div>
<div class="line">printf( <span class="stringliteral">&quot;(%zu/%zu):%s\n&quot;</span>, mslen(ms), mssz(ms), msbuf(ms) );</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// (2/128):ab</span></div>
<div class="line"><span class="comment">// (2/3):ab</span></div>
<div class="line"><span class="comment">// (2/128):ab</span></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md15"></a>
Hello World</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
Construct</h2>
<p>An <em>mstring</em> is typically constructed by calling <code>msnew()</code> (binary unsafe), <code>msmake()</code> (binary safe), or <code>msdup()</code> (duplication). These constructors invoke just one allocation for their internal buffer, according to their source argument.</p>
<p><code>msnew()</code> initially spends additional time in order to count the length of its source c-string. There is also <code>msnew2()</code> with an identical signature to <code>msnew()</code>. However internally <code>msnew2()</code> takes an alloc-ahead approach while parsing its source c-string. If the source c-string is really big, this may be faster compared to <code>msnew()</code>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Print</h2>
<p>Contrary to standard string functions, <em>MyStr</em> functions guarantee null-terminated <em>mstrings</em>. However, some <em>MyStr</em> functions provide direct access to the internal buffer, hence shifting the responsibility to the caller. These functions return a <code>const char *</code> pointer, as a hint for <em>read only</em> access (see also <em>Indexing &amp; Parsing</em>, below).</p>
<p><code>msbuf()</code> is such a function, making it easy to use <em>mstrings</em> with functions expecting regular <em>c-strings</em>. The most common such example is outputting <em>mstrings</em> using standard functions, like <code>printf()</code> and friends.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Destruct</h2>
<p>When an <em>mstring</em> is no longer needed, it should be destructed with either <code>msfree()</code> or <code>msfree0()</code>.</p>
<p>In most cases <code>msfree()</code> should suffice. It deallocates the memory reserved for its <em>mstring</em> argument and returns <code>NULL</code>, so we may assign it back to the <em>mstring</em> in the same line, to avoid leaving it as a dangling pointer.</p>
<p><code>msfree0()</code> is a "paranoid" variant doing 3 things at once: zeromemory, deallocation, and <code>NULL</code>ification. It expects the address of the <em>mstring</em> (e.g. <code>msfree0( &amp;ms );</code>). The rationale behind this function is to prevent our data from keep living in memory marked as "available" by the OS, after freeing. The function does not return anything, and depending on the <em>mstring</em> it can be considerably slower than <code>msfree()</code>.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Sample Code</h2>
<div class="fragment"><div class="line">MyStr *msnew( <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr );       <span class="comment">// binary-unsafe constructor</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *msbuf( <span class="keyword">const</span> MyStr *ms );   <span class="comment">// pointer to the internal buffer</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">MyStr *msfree( MyStr *ms );             <span class="comment">// destructor</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line">printf( <span class="stringliteral">&quot;%s\n&quot;</span>, msbuf(ms) );</div>
<div class="line">msfree( ms );   <span class="comment">// or for non-dangling: ms = msfree( ms );</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Output: Hello world!</span></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md21"></a>
Indexing &amp; Parsing</h1>
<p>Calling <code>msbuf()</code> is the main way of getting direct access to the internal buffer of an <em>mstring</em>.</p>
<blockquote class="doxtable">
<p>When a <em>MyStr</em> function returns a direct pointer to the internal buffer of an <em>mstring</em>, the type of the returned pointer is <code>const char *</code>. That's a reminder of the <b>recommended</b> <em>read-only</em> usage, since the pointer practically bypasses any kind of managed access. We can still use that pointer to directly alter the internal buffer by casting it to <code>char *</code>, but then we are obviously fully responsible for ensuring proper functionality. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md22"></a>
Unmanaged Parsing</h2>
<p>With <code>msbuf()</code> we can freely walk through the internal buffer of an <em>mstring</em>, meaning we can parse it in an <b>unmanaged</b> way. Put otherwise, we take full control in our hands.</p>
<p>In the following snippet we use the function to print the individual bytes of an <em>mstring</em> via a loop, relying on the implicit null-terminator as a sentinel value. The <code>const</code> declaration of the temporary <code>cp</code> pointer re-enforces our <em>read only</em> intention (Example 1), but we can also use array-subscript notation directly to <code>msbuf()</code> (Example 2).</p>
<p>Keep though in mind that this is not <b>not</b> a <em>binary-safe</em> way of parsing an <code>mstring</code> (we'll discuss alternatives a little later, see also the <em>Binary Safeness</em> section).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *msbuf( <span class="keyword">const</span> MyStr *ms );   <span class="comment">// pointer to the internal buffer</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Unmanaged, binary-unsafe parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXAMPLE 1: Using a pointer</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *cp = msbuf(ms); *cp; cp++) {</div>
<div class="line">    putchar( *cp );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXAMPLE 2: Using array-subscript notation</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; msbuf(ms)[i]; i++) {</div>
<div class="line">    putchar( msbuf(ms)[i] );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// Hello world!</span></div>
<div class="line"><span class="comment">// Hello world!</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Semi Managed Parsing</h2>
<p>The previous example has a few issues:</p>
<ul>
<li><code>msbuf(ms)</code> return value is not checked against <code>NULL</code> (if <code>NULL</code>, it crashes when trying later to dereference/subscript it)</li>
<li><code>i</code> is not checked against the <code>ms</code> boundaries (not really needed here, but still)</li>
</ul>
<p>Admittedly they sound a bit too far stretched for such a trivial example, but in a large code-base anything can happen or missed out right?</p>
<ul>
<li><code>MyStr *ms = msnew("Hello world!");</code> later... <code>ms = msfree(ms);</code> later... <code>putchar( msbuf(ms)[3] );</code></li>
<li><code>MyStr *ms = msnew("Hello world!");</code> later... <code>char c = msbuf(ms)[100];</code></li>
</ul>
<p>Without extra checking, these corner cases cause our code to either crash or overrun the internal buffer. We can prevent that without cluttering the code, by simply using the <b>managed</b> getter function <code>msiget()</code> instead of directly dereferencing <code>msbuf()</code>.</p>
<p><code>msiget()</code> returns the <code>char</code> (promoted to <code>int</code>) at the <code>i</code>th position of an <em>mstring</em> <code>ms</code>, ensuring that <code>ms</code> is non-<code>NULL</code> and that <code>i</code> is within the boundaries of the internal buffer (else it returns <code>EOF</code>). In our trivial example we don't check for <code>EOF</code> (though in real code we should).</p>
<p>The point is that contrary to the previous example, the following code fails gracefully even in corner cases (we'll talk about error-reporting a little later).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> msiget( <span class="keyword">const</span> MyStr *ms, <span class="keywordtype">size_t</span> i );    <span class="comment">// Get i&#39;th char of mstring.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Managed, binary-unsafe parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line"><span class="keywordtype">int</span> c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; (c = msiget(ms,i)); i++) {</div>
<div class="line">    putchar( c );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// Hello world!</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
Generic Managed Parsing (binary safe)</h2>
<p>There is also a generic parsing function, called <code>msfor()</code>. It is <em>binary-safe</em>, and fully managed (no need for manually looping, sanitizing, and keeping track of helper variables and counters). However, it's potentially slower because it expects a callback function.</p>
<div class="fragment"><div class="line">MyStr *msfor( MyStr *ms, <span class="keywordtype">size_t</span> step, <span class="keywordtype">bool</span> (*callback)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *userdata );</div>
</div><!-- fragment --><p>After doing all the necessary sanity checks, <code>msfor()</code> starts looping with the specified <code>step</code> over <code>ms</code>'s internal-buffer. On each iteration it calls the <code>callback</code> function, passing it a pointer pointing to the current byte in <code>ms</code>'s internal-buffer, along with the user provided <code>userdata</code> pointer. It stops when the internal-buffer gets exhausted, or when the callback function returns <code>false</code> (whichever comes first).</p>
<p>Using <code>msfor()</code>, our over-simplified example would look similar to the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Managed, binary-safe, generic parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// ----------------------------------------</span></div>
<div class="line">bool parse_callback( <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">void</span> *data )</div>
<div class="line">{</div>
<div class="line">    putchar( *buf );</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ----------------------------------------</span></div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line">    msfor( ms, 1, parse_callback, NULL );</div>
<div class="line">    msfree( ms );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// Hello world!</span></div>
</div><!-- fragment --><p>We'll talk about <em>Binary Safeness</em> a little later, in a dedicated section. It mostly means that if the <em>mstring</em> contains multiple null-bytes, then <code>msfor()</code> will <b>not</b> stop at the first found. It will keep going until the full length of the buffer gets exhausted.</p>
<p>We can "tell" <code>msfor()</code> to stop at the first null-byte, by adding a check in the callback function and have it return <code>false</code>. Obviously, this only makes sense when there are indeed multiple null-bytes inside the <em>mstring</em> (else it just adds needless overhead).</p>
<div class="fragment"><div class="line"><span class="comment">// ----------------------------------------</span></div>
<div class="line"><span class="keywordtype">bool</span> parse_callback( <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">void</span> *data )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// &quot;tell&quot; msfor() to stop when a null-byte is found</span></div>
<div class="line">    <span class="keywordflow">if</span> ( <span class="charliteral">&#39;\0&#39;</span> == *buf ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    putchar( *buf );</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md26"></a>
Error Handling &amp; Debugging</h1>
<p>In the previous section, the parsing loop in the <b>unmanaged</b> examples still never overruns the internal buffer of<code>ms</code>, because <em>mstrings</em> are implicitly null-terminated. However, they will crash if <code>ms</code> somehow ends up being <code>NULL</code> prior to the loop, because <code>msbuf(NULL)</code> will return <code>NULL</code> and obviously we cannot then dereference a <code>NULL</code> pointer.</p>
<p>We'll use the 1st unmanaged example (the one using a temporary <code>const char *</code> pointer), but the same applies to the 2nd example (the one using array-subscript notation). Remember that the managed example (also shown in the previous section) fails gracefully anyway.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Catching Errors</h2>
<p>Lets fix the unmanaged parsing code by adding an extra check for <code>cp</code> in the loop condition:</p>
<div class="fragment"><div class="line"><span class="comment">// Unmanaged, binary-unsafe parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *cp = msbuf(ms); cp &amp;&amp; *cp; cp++) { <span class="comment">// improved check, prevents crash when ms/cp == NULL</span></div>
<div class="line">    putchar( *cp );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output: Hello world!</span></div>
</div><!-- fragment --><p>Now the loop is not executed when <code>ms</code> is <code>NULL</code>, but we don't get notified either. All <em>MyStr</em> functions return errors, with <code>NULL</code> being by far the most common. They also set <code>errno</code> to either <code>EDOM</code> or <code>ERANGE</code> when they fail. This is consistent with the way the standard C library works, but <em>MyStr</em> functions perform much more error checking in comparison.</p>
<p>With that in mind, we can either rewrite the parsing loop to additionally emit an error message when <code>msbuf()</code> returns <code>NULL</code>, or we can use the standard C <code>errno</code> along with <code>perror()</code> or similar, right after the loop. Usually the latter results to simplified code.</p>
<p>In the following snippet, <code>ms</code> is <b>intentionally</b> passed as <code>NULL</code> to <code>msbuf()</code>, which causes the function to also return <code>NULL</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Unmanaged, binary-unsafe parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span>  <span class="comment">// for perror(), etc</span></div>
<div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span>  <span class="comment">// for errno, etc</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;Hello world!&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *cp = msbuf(NULL); cp &amp;&amp; *cp; cp++) {   <span class="comment">// intentionally passing NULL to msbuf()</span></div>
<div class="line">    putchar( *cp );</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> ( errno ) {      <span class="comment">// notify in case of error</span></div>
<div class="line">    perror( <span class="stringliteral">&quot;Something went wrong&quot;</span> );</div>
<div class="line">}</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
</div><!-- fragment --><div class="fragment"><div class="line">Something went wrong: Domain error</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Debugging</h2>
<p>For debugging, <em>MyStr</em> can provide automatic error-reporting (to <code>stderr</code>) and optionally exit the program immediately, via the <code>MSDEBUG</code> preprocessor directive. This requires re-compiling the library sources with <code>MSDEBUG</code> defined as a compiler flag (usually <code>-DMSDEBUG</code> or <code>/DMSDEBUG</code>, depending on the compiler). To enable immediate exit on errors, we can give <code>MSDEBUG</code> a value of 2 or greater (e.g. <code>-DMSDEBUG=2</code>). See also the section <em>Installation &amp; Dependencies</em>, above.</p>
<p>When <em>MyStr</em> is compiled with <code>-DMSDEBUG</code>, the output of the above snippet changes as follows:</p>
<div class="fragment"><div class="line">--- MyStr ERROR [ msbuf():855 ]</div>
<div class="line">==&gt; (EDOM) NULL function parameter (ms).</div>
<div class="line">Something went wrong: Domain error</div>
</div><!-- fragment --><p>Using <code>-DMSDEBUG=2</code> instead, <em>MyStr</em> exits our program immediately after reporting the error, so the last line above is never printed.</p>
<div class="fragment"><div class="line">--- MyStr ERROR [ msbuf():855 ]</div>
<div class="line">==&gt; Reporting &amp; exiting...</div>
<div class="line">==&gt; (EDOM) NULL function parameter (ms).</div>
</div><!-- fragment --><p>All <em>MyStr</em> debugging messages include the severity-type of the error, a brief description of the problem, the name of the failed function, and the specific line number in the source code of the library.</p>
<p>The severity-types are the following:</p><ul>
<li><code>ERROR</code> indicates hard failure (the function usually returns <code>NULL</code>)</li>
<li><code>WARNING/NOTE</code> indicate medium/soft failure (the function usually returns a pointer to the original <em>mstring</em>)</li>
</ul>
<p>To illustrate this, in the following example we use the re-entrant function <code>ms_fcat()</code> to gradually read a file in chunks of 32 bytes, storing its contents into an <em>mstring</em>. The size of this particular file is 142 bytes, which is not divisible by 32. Therefore the call to <code>ms_fcat()</code> in the last run of the loop will encounter <code>EOF</code> after reading only 14 bytes instead of the 32 requested. Partial reads are considered medium/soft failures, with the function returning a pointer to the resulting <em>mstring</em>. This leaves it up to the caller to decide whether they want to keep or discard it. On the other hand, on hard failures such as invalid arguments for example, the function returns <code>NULL</code> (hence causing the loop to stop immediately).</p>
<div class="fragment"><div class="line">MyStr *ms_fcat( MyStr *ms, FILE *fp, <span class="keywordtype">size_t</span> len );  <span class="comment">// Append file contents to mstring.</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msnew( <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">FILE *fp = fopen( <span class="stringliteral">&quot;filename.cfg&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span> );   <span class="comment">// if (!fp) { msfree(ms); exit(1); }</span></div>
<div class="line"><span class="keywordflow">while</span> ( ms_fcat(ms, fp, 32) ) {</div>
<div class="line">    printf( <span class="stringliteral">&quot;%zu bytes so far\n&quot;</span>, mslen(ms) );</div>
<div class="line">}</div>
<div class="line">fclose( fp );</div>
<div class="line">printf( <span class="stringliteral">&quot;Total bytes read: %zu\n&quot;</span>, mslen(ms) );</div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Output -------------</span></div>
<div class="line"><span class="comment">// 32 bytes so far</span></div>
<div class="line"><span class="comment">// 64 bytes so far</span></div>
<div class="line"><span class="comment">// 96 bytes so far</span></div>
<div class="line"><span class="comment">// 128 bytes so far</span></div>
<div class="line"><span class="comment">// *** MyStr WARNING [ ms_fcat():1142 ]</span></div>
<div class="line"><span class="comment">// ==&gt; Read 14 out of 32 requested bytes. Returned: ms</span></div>
<div class="line"><span class="comment">// 142 bytes so far</span></div>
<div class="line"><span class="comment">// Total bytes read: 142</span></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md30"></a>
Binary Safeness</h1>
<p>All <em>mstrings</em> are null-terminated, but they may also contain extra null-bytes if we choose so. In that case, they don't work properly with functions that parse regular <em>c-strings</em>, since all those functions stop parsing after the very first <code>'\0'</code></p>
<p>For that reason, <em>MyStr</em> provides a few binary-safe functions. For example, to construct a binary-safe <em>mstring</em> from a buffer of arbitrary bytes, we should use <code>msmake()</code> instead of <code>msnew()</code>. To see the contents of a binary-safe <em>mstring</em>, we may use the function <code>msdump()</code> instead of <code>puts()</code>/<code>printf()</code>/etc.</p>
<div class="fragment"><div class="line">MyStr *msmake( <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> len );   <span class="comment">// binary-safe constructor</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> msdump( <span class="keyword">const</span> MyStr *ms, <span class="keywordtype">int</span> base, <span class="keywordtype">char</span> sep );</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msmake( <span class="stringliteral">&quot;A\0BC&quot;</span>, 4 );   <span class="comment">// contains &#39;\0&#39; at pos 1</span></div>
<div class="line">fputs( msbuf(ms), stdout );         <span class="comment">// Output: A</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msdump( ms, 0, <span class="charliteral">&#39;\0&#39;</span> );              <span class="comment">// Output: A BC</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msfree( ms );</div>
</div><!-- fragment --><p>The comments in the snippet above show that <code>fputs()</code> stops after reaching <code>'\0'</code> at position 1, while <code>msdump()</code> outputs the whole buffer (<code>'\0'</code>s are printed as blanks here, but it really depends on the terminal font). Also, <code>msdump()</code> was used in "text mode" (the 2nd argument passed as 0), but for buffers of arbitrary bytes it makes more sense to use it in "hex mode" (16) or "binary mode" (2). We'll see examples in a little bit.</p>
<p>Contrary to <code>msnew()</code>, <code>msmake()</code> does <b>not</b> assume that the source buffer is a null-terminated <em>c-string</em>. Instead, it expects the length of the buffer as a 2nd argument. That is, the count of total bytes <b>excluding</b> the null-termination (if any), hence the name <em>len</em> in the prototype of the function. It trusts the caller for properly matched <em>buf</em> and <em>len</em>, but it always null-terminates the resulting <em>mstring</em> by appending an <b>extra</b> null-character at the end. This function is the main way of constructing <em>binary-safe mstrings</em>.</p>
<p>In the following snippet, the first example creates a <em>binary-safe mstring</em> containing only the first 3 bytes of <em>buf</em> plus a null-terminator (if we do that on purpose, then it's fine I guess). The second example specifies <em>len</em> to be longer than the actual length of <em>buf</em>. We shouldn't really do this, because <code>ms</code> ends up "thinking" it contains 10 usable bytes, not counting the null-terminator, but the last 6 are "garbage" really. The code also demonstrates <code>msdump()</code> usage in hex mode.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// 1st example</span></div>
<div class="line">MyStr *ms = msmake( <span class="stringliteral">&quot;A\0BC&quot;</span>, 3 );   <span class="comment">// ms takes in just the first 3 bytes of buf</span></div>
<div class="line">msdump( ms, 0, <span class="charliteral">&#39;\0&#39;</span> );              <span class="comment">// Text Output: A B</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msdump( ms, 16, <span class="charliteral">&#39;-&#39;</span> );              <span class="comment">// Hex Output: 41-00-42</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msfree( ms );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2nd example (DON&#39;T DO THIS)</span></div>
<div class="line">ms = msmake( <span class="stringliteral">&quot;A\0BC&quot;</span>, 10 );         <span class="comment">// ms takes in all 4 buf bytes + 6 &quot;garbage&quot; bytes</span></div>
<div class="line">msdump( ms, 0, <span class="charliteral">&#39;\0&#39;</span> );              <span class="comment">// Text Output: A BC    n(</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msdump( ms, 16, <span class="charliteral">&#39;-&#39;</span> );              <span class="comment">// Hex Output: 41-00-42-43-00-00-00-00-CE-28</span></div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line">msfree( ms );</div>
</div><!-- fragment --><p>We can also examine the bytes of an <em>mstring</em> in a <em>binary-safe</em> way, by parsing it manually using <code>msbuf()</code> and <code>mslen()</code>. Compared to the binary-unsafe loop shown in the <em>Hello World</em> section, the key difference is to control the loop with <code>mslen()</code>instead of relying on the first <code>'\0'</code> found in the buffer.</p>
<div class="fragment"><div class="line"><span class="comment">// binary-safe parsing</span></div>
<div class="line"><span class="preprocessor">#include &quot;mystr.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MyStr *ms = msmake( <span class="stringliteral">&quot;A\0BC&quot;</span>, 4 );   <span class="comment">// contains &#39;\0&#39; at pos 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Text Output: A BC</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *cp = msbuf( ms );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; mslen(ms); i++) {</div>
<div class="line">    putchar( *cp++ );</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hex Output: 41-00-42-43</span></div>
<div class="line">cp = msbuf( ms );</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; mslen(ms); i++, cp++) {</div>
<div class="line">    printf( <span class="stringliteral">&quot;%02X&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(*cp) );</div>
<div class="line">    <span class="comment">// visual separator between bytes</span></div>
<div class="line">    <span class="keywordflow">if</span> (i != mslen(ms) - 1) {</div>
<div class="line">        putchar( <span class="charliteral">&#39;-&#39;</span> );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">putchar( <span class="charliteral">&#39;\n&#39;</span> );</div>
<div class="line"> </div>
<div class="line">msfree( ms );</div>
<div class="line">...</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
